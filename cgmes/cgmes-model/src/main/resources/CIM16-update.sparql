#
# Copyright (c) 2025, RTE (http://www.rte-france.com)
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
# SPDX-License-Identifier: MPL-2.0
#

# query: fullModels
prefix md: <http://iec.ch/TC57/61970-552/ModelDescription/1#>
SELECT *
{ GRAPH ?graph {
    ?FullModel
        a md:FullModel ;
        md:Model.scenarioTime ?scenarioTime ;
        md:Model.created ?created ;
        md:Model.version ?version ;
        md:Model.modelingAuthoritySet ?modelingAuthoritySet .
    {
    SELECT ?FullModel (group_concat(?profile; separator=" ") as ?profileList)
        WHERE {
                ?FullModel md:Model.profile ?profile .
        } GROUP BY ?FullModel
    }
    OPTIONAL { ?FullModel md:Model.description ?description }
    OPTIONAL {
        SELECT ?FullModel (group_concat(?dependentOn; separator=" ") as ?dependentOnList)
            WHERE {
                    ?FullModel md:Model.DependentOn ?dependentOn .
            } GROUP BY ?FullModel
    }
    OPTIONAL {
        SELECT ?FullModel (group_concat(?supersedes; separator=" ") as ?supersedesList)
            WHERE {
                    ?FullModel md:Model.Supersedes ?supersedes .
            } GROUP BY ?FullModel
    }
}}

# query: numObjectsByType
# Only types in a namespace given as parameter
SELECT ?Type (COUNT (DISTINCT ?object) AS ?numObjects)
{ GRAPH ?graph {
     ?object a ?Type .
    FILTER (STRSTARTS(STR(?Type), "{0}"))
}}
GROUP BY ?Type

# query: allObjectsOfType
SELECT *
{ GRAPH ?graph {
     ?object a cim:{0} ;
     ?attribute ?value .
}}

# query: terminals
# we cannot access the 'inService' Status
SELECT *
{
    {
        SELECT DISTINCT ?Terminal
        WHERE {
            {
                ?Terminal a cim:Terminal .
            }
            UNION
            {
                SELECT ?Terminal
                WHERE {
                    ?SvPowerFlow a cim:SvPowerFlow ;
                        cim:SvPowerFlow.Terminal ?Terminal .
                }
            }
        }
    }
    OPTIONAL {
        ?Terminal cim:ACDCTerminal.connected ?connected .
    }
    OPTIONAL {
        ?SvPowerFlow a cim:SvPowerFlow ;
            cim:SvPowerFlow.Terminal ?Terminal ;
            cim:SvPowerFlow.p ?p ;
            cim:SvPowerFlow.q ?q .
    }
    OPTIONAL {
        ?Terminal cim:Terminal.TopologicalNode ?TopologicalNode .
    }
}

# query: operationalLimits
SELECT *
{
    ?OperationalLimit a ?type ;
        VALUES ?type { cim:CurrentLimit cim:ApparentPowerLimit cim:ActivePowerLimit cim:VoltageLimit } .
        OPTIONAL { ?OperationalLimit cim:CurrentLimit.value ?value }
        OPTIONAL { ?OperationalLimit cim:ApparentPowerLimit.value ?value }
        OPTIONAL { ?OperationalLimit cim:ActivePowerLimit.value ?value }
        OPTIONAL { ?OperationalLimit cim:VoltageLimit.value ?value }
}

# query: svVoltages
SELECT *
WHERE {
    ?SvVoltage a cim:SvVoltage ;
        cim:SvVoltage.TopologicalNode ?TopologicalNode ;
        cim:SvVoltage.v ?v ;
        cim:SvVoltage.angle ?angle .
}

# query: svInjections
SELECT *
WHERE {
    ?SvInjection
        a cim:SvInjection ;
        cim:SvInjection.TopologicalNode ?TopologicalNode ;
        cim:SvInjection.pInjection ?pInjection .
        OPTIONAL { ?SvInjection cim:SvInjection.qInjection ?qInjection }
    OPTIONAL {
        SELECT ?TopologicalNode (MIN(?Terminal) AS ?Terminal)
        WHERE {
            ?Terminal cim:Terminal.TopologicalNode ?TopologicalNode
        }
        GROUP BY ?TopologicalNode
    }
}

# query: switches
SELECT *
{
    ?Switch a ?type ;
        cim:Switch.open ?open .
    VALUES ?type { cim:Switch cim:Breaker cim:Disconnector cim:LoadBreakSwitch cim:ProtectedSwitch cim:GroundDisconnector }
}

# query: ratioTapChangers
SELECT *
{
    {
        SELECT DISTINCT ?RatioTapChanger
        WHERE {
            {
                ?RatioTapChanger a cim:RatioTapChanger .
            }
            UNION
            {
                SELECT ?RatioTapChanger
                WHERE {
                    ?SvTapStep a cim:SvTapStep ;
                        cim:SvTapStep.TapChanger ?RatioTapChanger .
                }
            }
        }
    }
    OPTIONAL {
        ?RatioTapChanger
            cim:TapChanger.controlEnabled ?tapChangerControlEnabled ;
            cim:TapChanger.step ?step .
    }
    OPTIONAL {
        ?SvTapStep a cim:SvTapStep ;
            cim:SvTapStep.TapChanger ?RatioTapChanger ;
            cim:SvTapStep.position ?SVtapStep .
    }
}

# query: phaseTapChangers
SELECT *
{
    {
        SELECT DISTINCT ?PhaseTapChanger
        WHERE {
            {
                ?PhaseTapChanger a ?phaseTapChangerType ;
                VALUES ?phaseTapChangerType { cim:PhaseTapChangerLinear cim:PhaseTapChangerAsymmetrical cim:PhaseTapChangerNonLinear cim:PhaseTapChangerTabular } .
            }
            UNION
            {
                SELECT ?PhaseTapChanger
                WHERE {
                    ?SvTapStep a cim:SvTapStep ;
                        cim:SvTapStep.TapChanger ?PhaseTapChanger .
                }
            }
        }
    }
    OPTIONAL {
        ?PhaseTapChanger
            cim:TapChanger.controlEnabled ?tapChangerControlEnabled ;
            cim:TapChanger.step ?step .
    }
    OPTIONAL {
        ?SvTapStep a cim:SvTapStep ;
            cim:SvTapStep.TapChanger ?PhaseTapChanger ;
            cim:SvTapStep.position ?SVtapStep .
    }
}

# query: regulatingControls
SELECT *
{
    ?RegulatingControl a ?type ;
        VALUES ?type { cim:RegulatingControl cim:TapChangerControl } .
    OPTIONAL {
        ?RegulatingControl
            cim:RegulatingControl.enabled ?enabled ;
            cim:RegulatingControl.targetValue ?targetValue ;
            cim:RegulatingControl.targetValueUnitMultiplier ?targetValueUnitMultiplier ;
            cim:RegulatingControl.discrete ?discrete .
        OPTIONAL { ?RegulatingControl cim:RegulatingControl.targetDeadband ?targetDeadband }
    }
}

# query: energyConsumers
SELECT *
{
    ?EnergyConsumer a ?type ;
            cim:EnergyConsumer.p ?p ;
            cim:EnergyConsumer.q ?q .
    VALUES ?type { cim:EnergyConsumer cim:ConformLoad cim:NonConformLoad cim:StationSupply }
}

# query: energySources
SELECT *
{
    ?EnergySource a cim:EnergySource ;
            cim:EnergySource.activePower ?p ;
            cim:EnergySource.reactivePower ?q
}

# FIXME(Luma) we do not have access to the type when reading update only files,
# we cannot differentiate between generators and condensers
# this means that we may not deprecate synchronousMachines in the end,
# or we could make the new query "synchronousMachinesForUpdate"

# query: synchronousMachinesForUpdate
SELECT *
{
    ?SynchronousMachine a cim:SynchronousMachine
    # FIXME(Luma) p in a separate optional block because condensers could not define it
    OPTIONAL { ?SynchronousMachine cim:RotatingMachine.p ?p }
    OPTIONAL {
        ?SynchronousMachine
            cim:RotatingMachine.q ?q ;
            cim:SynchronousMachine.referencePriority ?referencePriority ;
            cim:SynchronousMachine.operatingMode ?operatingMode ;
            cim:RegulatingCondEq.controlEnabled ?controlEnabled .
        # For condensers giving p is optional,
    }
}

# query: generatingUnits
SELECT *
{
    ?GeneratingUnit
        a ?generatingUnitType ;
        cim:GeneratingUnit.normalPF ?normalPF
}

# query: equivalentInjections
SELECT *
{
    ?EquivalentInjection a cim:EquivalentInjection ;
        cim:EquivalentInjection.p ?p ;
        cim:EquivalentInjection.q ?q .
    OPTIONAL { ?EquivalentInjection cim:EquivalentInjection.regulationStatus ?regulationStatus }
    OPTIONAL { ?EquivalentInjection cim:EquivalentInjection.regulationTarget ?regulationTarget }
}

# query: externalNetworkInjections
SELECT *
{
    ?ExternalNetworkInjection  a cim:ExternalNetworkInjection ;
        cim:ExternalNetworkInjection.p ?p ;
        cim:ExternalNetworkInjection.q ?q ;
        cim:RegulatingCondEq.controlEnabled ?controlEnabled
}

# query: asynchronousMachines
SELECT *
{
    ?AsynchronousMachine a cim:AsynchronousMachine ;
        cim:AsynchronousMachine.asynchronousMachineType ?type ;
        cim:RotatingMachine.p ?p ;
        cim:RotatingMachine.q ?q ;
        cim:RegulatingCondEq.controlEnabled ?controlEnabled
}

# query: staticVarCompensators
SELECT *
{
    ?StaticVarCompensator a cim:StaticVarCompensator ;
        cim:StaticVarCompensator.q ?q ;
        cim:RegulatingCondEq.controlEnabled ?controlEnabled
}

# query: shuntCompensators
SELECT *
{
    {
        SELECT DISTINCT ?ShuntCompensator
        WHERE {
            {
                ?ShuntCompensator a ?type ;
                VALUES ?type { cim:LinearShuntCompensator cim:NonlinearShuntCompensator } .
            }
            UNION
            {
                SELECT ?ShuntCompensator
                WHERE {
                    ?SvShuntCompensatorSections a cim:SvShuntCompensatorSections ;
                        cim:SvShuntCompensatorSections.ShuntCompensator ?ShuntCompensator .
                }
            }
        }
    }
    OPTIONAL {
        ?ShuntCompensator
            cim:ShuntCompensator.sections ?SSHsections ;
            cim:RegulatingCondEq.controlEnabled ?controlEnabled
    }
    OPTIONAL {
        ?SvShuntCompensatorSections a cim:SvShuntCompensatorSections ;
            cim:SvShuntCompensatorSections.ShuntCompensator ?ShuntCompensator ;
            cim:SvShuntCompensatorSections.sections ?SVsections .
    }
}

# query: acDcConverters
SELECT *
{
    {
        SELECT DISTINCT ?ACDCConverter
        WHERE {
            ?ACDCConverter a ?type ;
            VALUES ?type { cim:ACDCConverter cim:CsConverter cim:VsConverter } .
        }
    }
    OPTIONAL {
        ?ACDCConverter
            cim:ACDCConverter.targetPpcc ?targetPpcc ;
            cim:ACDCConverter.p ?p ;
            cim:ACDCConverter.q ?q .
    }
    # From SV, for all converters
    OPTIONAL {
        ?ACDCConverter cim:ACDCConverter.poleLossP ?poleLossP
    }
    # For Current Source Converter
    OPTIONAL {
        ?ACDCConverter a cim:CsConverter ;
            cim:CsConverter.operatingMode ?operatingMode ;
            cim:CsConverter.pPccControl ?controlMode .
            OPTIONAL { ?ACDCConverter cim:ACDCConverter.targetUdc ?targetUdc }
    }
    # For Voltage Source Converter
    OPTIONAL {
        ?ACDCConverter a cim:VsConverter ;
            cim:VsConverter.qPccControl ?qPccControl ;
            cim:VsConverter.pPccControl ?pPccControl .
            OPTIONAL { ?ACDCConverter cim:VsConverter.targetQpcc ?targetQpcc }
            OPTIONAL { ?ACDCConverter cim:VsConverter.targetUpcc ?targetUpcc }
    }
}

# query: controlAreas
SELECT *
{
    ?ControlArea a cim:ControlArea ;
        cim:ControlArea.netInterchange ?netInterchange .
    OPTIONAL { ?ControlArea cim:ControlArea.pTolerance ?pTolerance }
}
